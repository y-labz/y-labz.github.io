<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Matrix Complex Orbit</title>
  <style>
    html, body {
      background: black;
      margin: 0;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      margin: auto;
      background-color: black;
      box-shadow: 0 0 20px #0f0;
      border: 2px solid #0f0;
      cursor: crosshair;
      touch-action: none;
    }
  </style>
</head>
<body>
<canvas id="canvas" width="800" height="800"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const width = canvas.width;
const height = canvas.height;
const range = 10;
const iterations = 7;

function toCanvasCoords(z) {
  return {
    x: (z.re + range) * (width / (2 * range)),
    y: (range - z.im) * (height / (2 * range))
  };
}

function toComplexCoords(x, y) {
  return {
    re: (x / width) * 2 * range - range,
    im: range - (y / height) * 2 * range
  };
}

let z0 = { re: -1, im: 0.2 };
let C = { re: 0.3, im: 0.4 };
let dragging = null;

function distance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function getEventPos(e) {
  if (e.touches && e.touches.length > 0) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  } else {
    return { x: e.offsetX, y: e.offsetY };
  }
}

canvas.addEventListener("mousedown", e => {
  const mouse = toComplexCoords(e.offsetX, e.offsetY);
  if (distance(toCanvasCoords(z0), e) < 10) dragging = 'z0';
  else if (distance(toCanvasCoords(C), e) < 10) dragging = 'C';
});

canvas.addEventListener("mousemove", e => {
  if (!dragging) return;
  const p = toComplexCoords(e.offsetX, e.offsetY);
  if (dragging === 'z0') z0 = p;
  else if (dragging === 'C') C = p;
  draw();
});

canvas.addEventListener("mouseup", () => dragging = null);
canvas.addEventListener("mouseleave", () => dragging = null);

// ðŸ’… Touch Support
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const pos = getEventPos(e);
  const mouse = toComplexCoords(pos.x, pos.y);
  if (distance(toCanvasCoords(z0), pos) < 20) dragging = 'z0';
  else if (distance(toCanvasCoords(C), pos) < 20) dragging = 'C';
});

canvas.addEventListener("touchmove", e => {
  if (!dragging) return;
  const pos = getEventPos(e);
  const p = toComplexCoords(pos.x, pos.y);
  if (dragging === 'z0') z0 = p;
  else if (dragging === 'C') C = p;
  draw();
});

canvas.addEventListener("touchend", () => dragging = null);
canvas.addEventListener("touchcancel", () => dragging = null);

function draw() {
  ctx.clearRect(0, 0, width, height);
  
  // draw axes
  ctx.strokeStyle = "#0f0";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, height / 2);
  ctx.lineTo(width, height / 2);
  ctx.moveTo(width / 2, 0);
  ctx.lineTo(width / 2, height);
  ctx.stroke();

  // draw orbit
  let zn = { ...z0 };
  const points = [toCanvasCoords(zn)];
  let diverged = false;

  for (let i = 0; i < iterations; i++) {
    zn = {
      re: zn.re * zn.re - zn.im * zn.im + C.re,
      im: 2 * zn.re * zn.im + C.im
    };
    points.push(toCanvasCoords(zn));
    if (Math.hypot(zn.re, zn.im) > 2) {
      diverged = true;
      break;
    }
  }

  ctx.lineWidth = 2;
  ctx.strokeStyle = diverged ? "#f00" : "#0f0";
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let p of points.slice(1)) {
    ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();

  function drawPoint(z, color) {
    const p = toCanvasCoords(z);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = '#0f0';
    ctx.stroke();
  }

  drawPoint(z0, "#ff0"); // Yellow
  drawPoint(C, "#0ff");  // Cyan
}

draw();
</script>
</body>
</html>
