<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TRON Maze Pulse</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: black;
    }
  </style>
</head>
<body>
<canvas id="mazeCanvas"></canvas>
<audio id="tronAudio" loop autoplay>
  <source src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_e8f8181725.mp3?filename=synthwave-background-110624.mp3" type="audio/mpeg">
</audio>

<script>
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  // canvas.width = window.innerWidth;
  // canvas.height = window.innerHeight;
  canvas.width = 400;
  canvas.height = 400;

  const cellSize = 40;
  const cols = Math.floor(canvas.width / cellSize);
  const rows = Math.floor(canvas.height / cellSize);
  const grid = [];
  const stack = [];

  const trail = [];
  const maxTrailLength = 100;

  let pulseTime = 0;

  class Cell {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.walls = [true, true, true, true]; // top, right, bottom, left
      this.visited = false;
    }

    show(ctx, glowStrength) {
      const x = this.x * cellSize;
      const y = this.y * cellSize;

      ctx.strokeStyle = "#00faff";
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = glowStrength;
      ctx.lineWidth = 4;

      if (this.walls[0]) drawLine(x, y, x + cellSize, y);
      if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize);
      if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize);
      if (this.walls[3]) drawLine(x, y + cellSize, x, y);

      ctx.shadowBlur = 0;
    }

    highlight(ctx, color = "#00ffcc33") {
      const x = this.x * cellSize;
      const y = this.y * cellSize;
      ctx.fillStyle = color;
      ctx.fillRect(x, y, cellSize, cellSize);
    }

    checkNeighbors() {
      const neighbors = [];
      const top = grid[index(this.x, this.y - 1)];
      const right = grid[index(this.x + 1, this.y)];
      const bottom = grid[index(this.x, this.y + 1)];
      const left = grid[index(this.x - 1, this.y)];

      if (top && !top.visited) neighbors.push(top);
      if (right && !right.visited) neighbors.push(right);
      if (bottom && !bottom.visited) neighbors.push(bottom);
      if (left && !left.visited) neighbors.push(left);

      if (neighbors.length > 0) {
        return neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        return undefined;
      }
    }
  }

  function index(x, y) {
    if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
    return x + y * cols;
  }

  function drawLine(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function removeWalls(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    if (dx === 1) { a.walls[3] = false; b.walls[1] = false; }
    if (dx === -1) { a.walls[1] = false; b.walls[3] = false; }
    if (dy === 1) { a.walls[0] = false; b.walls[2] = false; }
    if (dy === -1) { a.walls[2] = false; b.walls[0] = false; }
  }

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid.push(new Cell(x, y));
    }
  }

  let current = grid[0];
  let solving = false;
  let solvedPath = [];
  let solutionIndex = 0;

  function draw() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Pulse glow intensity between 6 and 20 using sine wave
    // pulseTime += 0.03;
    pulseTime += 0.1;
    // const glowStrength = 6 + Math.sin(pulseTime) * 14;
    const glowStrength = 10 + Math.sin(pulseTime) * 4;

    for (let i = 0; i < grid.length; i++) {
      grid[i].show(ctx, glowStrength);
    }

    if (!solving) {
      current.visited = true;
      current.highlight(ctx);

      const next = current.checkNeighbors();
      if (next) {
        next.visited = true;
        stack.push(current);
        removeWalls(current, next);
        current = next;
      } else if (stack.length > 0) {
        current = stack.pop();
      } else {
        solving = true;
        solvedPath = [...solveMaze(grid[0], grid[grid.length - 1])];
      }
    } else {
      animateLightcycle();
    }

    requestAnimationFrame(draw);
  }

  function solveMaze(start, end) {
    const visited = new Set();
    const cameFrom = new Map();
    const queue = [start];

    while (queue.length > 0) {
      const current = queue.shift();
      if (current === end) break;
      visited.add(current);

      const neighbors = getOpenNeighbors(current);
      for (let n of neighbors) {
        if (!visited.has(n)) {
          cameFrom.set(n, current);
          queue.push(n);
        }
      }
    }

    const path = [];
    let currentNode = end;
    while (currentNode !== start) {
      path.push(currentNode);
      currentNode = cameFrom.get(currentNode);
    }
    path.push(start);
    return path.reverse();
  }

  function getOpenNeighbors(cell) {
    const result = [];
    const x = cell.x;
    const y = cell.y;

    if (!cell.walls[0]) result.push(grid[index(x, y - 1)]);
    if (!cell.walls[1]) result.push(grid[index(x + 1, y)]);
    if (!cell.walls[2]) result.push(grid[index(x, y + 1)]);
    if (!cell.walls[3]) result.push(grid[index(x - 1, y)]);

    return result;
  }

  function animateLightcycle() {
    drawTrail();

    if (solutionIndex < solvedPath.length) {
      const cell = solvedPath[solutionIndex];
      trail.push({ x: cell.x, y: cell.y, alpha: 1.0 });
      solutionIndex++;

      // Cycle head glow
      const x = cell.x * cellSize + cellSize / 2;
      const y = cell.y * cellSize + cellSize / 2;
      ctx.shadowBlur = 20;
      ctx.shadowColor = "#ff00ff";
      ctx.fillStyle = "#ff00ff";
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    if (trail.length > maxTrailLength) trail.shift();
  }

  function drawTrail() {
    for (let i = 0; i < trail.length; i++) {
      const t = trail[i];
      const x = t.x * cellSize + cellSize / 2;
      const y = t.y * cellSize + cellSize / 2;

      const radius = 6 + (trail.length - i) * 0.3;
      const alpha = t.alpha * (1 - i / trail.length);

      const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
      gradient.addColorStop(0, `rgba(255,0,255,${alpha})`);
      gradient.addColorStop(1, `rgba(0,0,0,0)`);

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  draw();
</script>
</body>
</html>

