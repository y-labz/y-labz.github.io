<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TRON Maze Generator</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: black;
    }
  </style>
</head>
<body>
<canvas id="mazeCanvas"></canvas>
<audio id="tronAudio" loop autoplay>
  <source src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_e8f8181725.mp3?filename=synthwave-background-110624.mp3" type="audio/mpeg">
</audio>

<script>
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const cellSize = 30;
  const cols = Math.floor(canvas.width / cellSize);
  const rows = Math.floor(canvas.height / cellSize);
  const grid = [];
  const stack = [];
  const path = [];

  function Cell(x, y) {
    this.x = x;
    this.y = y;
    this.walls = [true, true, true, true]; // top, right, bottom, left
    this.visited = false;

    this.show = function(ctx) {
      const x = this.x * cellSize;
      const y = this.y * cellSize;

      ctx.strokeStyle = "#00faff";
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = 10;
      ctx.lineWidth = 4;

      if (this.walls[0]) drawLine(x, y, x + cellSize, y);             // top
      if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize); // right
      if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize); // bottom
      if (this.walls[3]) drawLine(x, y + cellSize, x, y);             // left

      ctx.shadowBlur = 0;
    };

    this.highlight = function(ctx, color = "#00ffcc33") {
      const x = this.x * cellSize;
      const y = this.y * cellSize;
      ctx.fillStyle = color;
      ctx.fillRect(x, y, cellSize, cellSize);
    };

    this.checkNeighbors = function() {
      const neighbors = [];

      const top = grid[index(this.x, this.y - 1)];
      const right = grid[index(this.x + 1, this.y)];
      const bottom = grid[index(this.x, this.y + 1)];
      const left = grid[index(this.x - 1, this.y)];

      if (top && !top.visited) neighbors.push(top);
      if (right && !right.visited) neighbors.push(right);
      if (bottom && !bottom.visited) neighbors.push(bottom);
      if (left && !left.visited) neighbors.push(left);

      if (neighbors.length > 0) {
        return neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        return undefined;
      }
    };
  }

  function index(x, y) {
    if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
    return x + y * cols;
  }

  function drawLine(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function removeWalls(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    if (dx === 1) { a.walls[3] = false; b.walls[1] = false; }
    if (dx === -1) { a.walls[1] = false; b.walls[3] = false; }
    if (dy === 1) { a.walls[0] = false; b.walls[2] = false; }
    if (dy === -1) { a.walls[2] = false; b.walls[0] = false; }
  }

  // Grid init
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid.push(new Cell(x, y));
    }
  }

  let current = grid[0];
  let solving = false;
  let solvedPath = [];
  let solutionIndex = 0;

  function draw() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < grid.length; i++) {
      grid[i].show(ctx);
    }

    if (!solving) {
      current.visited = true;
      current.highlight(ctx);

      const next = current.checkNeighbors();
      if (next) {
        next.visited = true;
        stack.push(current);
        removeWalls(current, next);
        current = next;
      } else if (stack.length > 0) {
        current = stack.pop();
      } else {
        solving = true;
        solvedPath = [...solveMaze(grid[0], grid[grid.length - 1])];
      }
    } else {
      animateLightcycle();
    }

    requestAnimationFrame(draw);
  }

  function solveMaze(start, end) {
    const visited = new Set();
    const cameFrom = new Map();
    const queue = [start];

    while (queue.length > 0) {
      const current = queue.shift();
      if (current === end) break;
      visited.add(current);

      const neighbors = getOpenNeighbors(current);
      for (let n of neighbors) {
        if (!visited.has(n)) {
          cameFrom.set(n, current);
          queue.push(n);
        }
      }
    }

    const path = [];
    let currentNode = end;
    while (currentNode !== start) {
      path.push(currentNode);
      currentNode = cameFrom.get(currentNode);
    }
    path.push(start);
    return path.reverse();
  }

  function getOpenNeighbors(cell) {
    const result = [];
    const x = cell.x;
    const y = cell.y;

    if (!cell.walls[0]) result.push(grid[index(x, y - 1)]); // top
    if (!cell.walls[1]) result.push(grid[index(x + 1, y)]); // right
    if (!cell.walls[2]) result.push(grid[index(x, y + 1)]); // bottom
    if (!cell.walls[3]) result.push(grid[index(x - 1, y)]); // left

    return result;
  }

  function animateLightcycle() {
    for (let i = 0; i < solvedPath.length; i++) {
      if (i < solutionIndex) {
        solvedPath[i].highlight(ctx, "#00ffcc33");
      }
    }

    if (solutionIndex < solvedPath.length) {
      const cell = solvedPath[solutionIndex];
      const x = cell.x * cellSize + cellSize / 2;
      const y = cell.y * cellSize + cellSize / 2;
      ctx.fillStyle = "#ff00ff";
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.fill();
      solutionIndex += 1;
    }
  }

  draw();
</script>
</body>
</html>
